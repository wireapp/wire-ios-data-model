//
// Wire
// Copyright (C) 2016 Wire Swiss GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.
//

import Foundation
import ZMCSystem
import zimages
import PINCache

private let NSManagedObjectContextImageAssetCacheKey = "zm_imageAssetCache"

extension NSManagedObjectContext
{
    public var zm_imageAssetCache : ImageAssetCache! {
        get {
            return self.userInfo[NSManagedObjectContextImageAssetCacheKey] as? ImageAssetCache
        }
        
        set {
            self.userInfo[NSManagedObjectContextImageAssetCacheKey] = newValue
        }
    }
}

protocol Cache {
    
    /// Returns the asset data for a given key. This will probably cause I/O
    func assetData(_ key: String) -> Data?
    
    /// Returns the file URL (if any) for a given key.
    func assetURL(_ key: String) -> URL?
    
    /// Stores the asset data for a given key. This will probably cause I/O
    func storeAssetData(_ data: Data, key: String)
    
    /// Stores the asset data for a source url that must be a local file. This will probably cause I/O
    func storeAssetFromURL(_ url: URL, key: String)
    
    /// Deletes the data for a key. This will cause I/O
    func deleteAssetData(_ key: String)
    
    /// Checks if the data exists in the cache. Faster than checking the data itself
    func hasDataForKey(_ key: String) -> Bool
}


/// Cache for assets contained in messages
struct PINAssetCache : Cache {
    
    let assetsCache : PINCache
    
    /// Creates an asset cache
    /// - parameter name: name of the cache
    /// - parameter MBLimit: maximum size of the cache on disk in MB
    /// - parameter location: where on disk cache is persisted
    init(name: String, MBLimit : UInt, location: URL? = nil) {
        if let rootPath = location?.path {
            self.assetsCache = PINCache(name: name, rootPath: rootPath)
        } else {
            self.assetsCache = PINCache(name: name)
        }
        self.assetsCache.makeURLSecure()
        self.assetsCache.configureLimits(MBLimit * 1024 * 1024)
    }
    
    func assetURL(_ key: String) -> URL? {
        return nil // URLs on disk generated by this cache are not binary dumps of the data,
                    // but archived NSData and should not be accessed directly, so this returns nil
    }
    
    func assetData(_ key: String) -> Data? {
        return self.assetsCache.object(forKey: key) as? Data
    }
    
    func storeAssetFromURL(_ url: URL, key: String) {
        guard url.scheme == NSURLFileScheme, let data = try? Data(contentsOf: url) else { fatal("Can't read data from URL \(url)") }
        self.storeAssetData(data, key: key)
    }
    
    func storeAssetData(_ data: Data, key: String) {
        self.assetsCache.setObject(data as NSCoding, forKey: key)
    }
    
    func deleteAssetData(_ key: String) {
        self.assetsCache.removeObject(forKey: key)
    }
    
    func wipeCache() {
        assetsCache.removeAllObjects()
    }
    
    func hasDataForKey(_ key: String) -> Bool {
        return self.assetData(key) != nil
    }
}

// MARK: - Image assets
open class ImageAssetCache : NSObject {

    let cache : PINAssetCache
    
    /// Creates an asset cache for images
    /// - parameter MBLimit: maximum size of the cache on disk in MB
    public init(MBLimit: UInt, location: URL? = nil) {
        self.cache = PINAssetCache(name: "images", MBLimit: MBLimit, location: location)
    }
    
    /// Returns the asset data for a given message and format tag. This will probably cause I/O
    open func assetData(_ messageID: UUID, format: ZMImageFormat, encrypted: Bool) -> Data? {
        return self.cache.assetData(type(of: self).cacheKeyForAsset(messageID, format: format, encrypted: encrypted))
    }
    
    /// Sets the asset data for a given message and format tag. This will cause I/O
    open func storeAssetData(_ messageID: UUID, format: ZMImageFormat, encrypted: Bool, data: Data) {
        self.cache.storeAssetData(data, key: type(of: self).cacheKeyForAsset(messageID, format: format, encrypted: encrypted))
    }
    
    /// Deletes the data for a given message and format tag. This will cause I/O
    open func deleteAssetData(_ messageID: UUID, format: ZMImageFormat, encrypted: Bool) {
        self.cache.deleteAssetData(type(of: self).cacheKeyForAsset(messageID, format: format, encrypted: encrypted))
    }
    
    /// Returns the cache key for an asset
    static func cacheKeyForAsset(_ messageID: UUID, format: ZMImageFormat) -> String {
        return self.cacheKeyForAsset(messageID, format: format, encrypted: false);
    }
    
    /// Returns the cache key for an asset
    static func cacheKeyForAsset(_ messageID: UUID, format: ZMImageFormat, encrypted: Bool) -> String {
        let tagComponent = StringFromImageFormat(format)
        let encryptedComponent = encrypted ? "_encrypted" : ""
        return "\(messageID.transportString())_\(tagComponent)\(encryptedComponent)"
    }
}

public extension ImageAssetCache {
    func wipeCache() {
        cache.wipeCache()
    }
}
